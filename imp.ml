(* 
 * Follows Glynn Winskel's _The Formal Semantics of Programming Languages_
 *
 * This is an abstract syntax for IMP. 
 *
 * Do not edit this file -- instead, edit hw1.ml.
 *)

type loc = string

type aexp =  (* Winskel page 12 *) 
  | Const of int                (* n *)
  | Var of loc                  (* x *)
  | Add of aexp * aexp          (* a0 + a1 *) 
  | Sub of aexp * aexp          (* a0 - a1 *) 
  | Mul of aexp * aexp          (* a0 * a1 *) 
  | Div of aexp * aexp          (* a0 / a1 *) 
  | Mod of aexp * aexp          (* a0 % a1 *) 

type bexp =
  | True
  | False
  | EQ of aexp * aexp           (* a0 == a1 *) 
  | LE of aexp * aexp           (* a0 <= a2 *) 
  | Not of bexp                 (* !b *)
  | And of bexp * bexp          (* b0 /\ b1 *) (* b0 && b1 *) 
  | Or of bexp * bexp           (* b0 \/ b1 *) (* b0 || b1 *) 

type com =
  | Skip
  | Set of loc * aexp           (* x := a *) 
  | Seq of com * com            (* c0 ; c1 *)
  | If of bexp * com		(* if b then c end *)
  | Ifelse of bexp * com * com  (* if b then c0 end else c1 end *)
  | While of bexp * com         (* while b do c *)

  (* these special new commands are added for homework #1 *) 
  | Print of aexp               (* print a *) 
  | Declareint of loc		(* Integer i *)
  | Declareproto of loc * loc * loc


(* Pretty-printing utility functions -- these aren't necessary but might be
 * handy for debugging. They convert instances of Aexp, Bexp and Com into
 * strings (that you can print out later with print_string, say). *) 
module P = Printf 

let rec aexp_to_str a = match a with
  | Const n -> string_of_int n
  | Var l -> l
  | Add (a, b) -> P.sprintf "(%s + %s)" (aexp_to_str a) (aexp_to_str b)
  | Sub (a, b) -> P.sprintf "(%s - %s)" (aexp_to_str a) (aexp_to_str b)
  | Mul (a, b) -> P.sprintf "(%s * %s)" (aexp_to_str a) (aexp_to_str b)
  | Div (a, b) -> P.sprintf "(%s / %s)" (aexp_to_str a) (aexp_to_str b)
  | Mod (a, b) -> P.sprintf "(%s %% %s)" (aexp_to_str a) (aexp_to_str b)

and bexp_to_str b = match b with
  | True -> "true"
  | False -> "false" 
  | EQ (a, b) -> P.sprintf "(%s = %s)" (aexp_to_str a) (aexp_to_str b) 
  | LE (a, b) -> P.sprintf "(%s <= %s)" (aexp_to_str a) (aexp_to_str b) 
  | Not b -> P.sprintf "!%s" (bexp_to_str b) 
  | And (a, b) -> P.sprintf "(%s && %s)" (bexp_to_str a) (bexp_to_str b)
  | Or (a, b) -> P.sprintf "(%s || %s)" (bexp_to_str a) (bexp_to_str b)

and com_to_str c = match c with
  | Skip -> "skip"
  | Set (l, a) -> P.sprintf "%s = %s" l (aexp_to_str a)
  | Seq (a, b) -> P.sprintf "%s ;\n%s" (com_to_str a) (com_to_str b)
  | If (b, c) -> P.sprintf "if (%s) { %s; }" (bexp_to_str b) (com_to_str c)
  | Ifelse (b, c0, c1) ->
      P.sprintf "if (%s) { %s; } else { %s; }"
	(bexp_to_str b) (com_to_str c0) (com_to_str c1) 
  | While (b, c) ->
      P.sprintf "{ while %s do %s }" (bexp_to_str b) (com_to_str c) 
  | Print a -> P.sprintf "print %s" (aexp_to_str a)
  | Declareint l -> P.sprintf "int %s" l
  | Declareproto (l1, l2, l3) -> P.sprintf "%s %s" l3 l1

let rec find_include c = match c with
  | Skip -> ""
  | Set (l, a) -> "" 
  | Seq (a, b) -> P.sprintf "%s\n%s" (find_include a) (find_include b)
  | If (b, c) -> P.sprintf "%s" (find_include c)
  | Ifelse (b, c0, c1) -> P.sprintf "%s\n%s" (find_include c0) (find_include c1)
  | While (b, c) -> P.sprintf "%s" (find_include c)
  | Print a -> ""
  | Declareint l -> ""
  | Declareproto (l1, l2, l3) -> P.sprintf "#include \"%s.pb.h\"" l2

