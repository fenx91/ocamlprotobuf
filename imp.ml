(*
 * Follows Glynn Winskel's _The Formal Semantics of Programming Languages_
 *
 * This is an abstract syntax for IMP. 
 *
 * Do not edit this file -- instead, edit hw1.ml.
 *)


type loc = string

type exp_inside =
  | ExpEle1 of loc
  | ExpEle2 of loc * int
  | ExpEle3 of exp_inside * exp_inside

type pro_ele =
  | Var of loc
  | AccessProto1 of loc * exp_inside * loc
  | AccessProto2 of loc * exp_inside * loc * int
  | AccessProto3 of loc * loc
  | AccessProto4 of loc * loc * int 

type aexp =  (* Winskel page 12 *) 
  | Const of int                (* n *)
  | Var of loc
  | Add of aexp * aexp          (* a0 + a1 *) 
  | Sub of aexp * aexp          (* a0 - a1 *) 
  | Mul of aexp * aexp          (* a0 * a1 *) 
  | Div of aexp * aexp          (* a0 / a1 *) 
  | Mod of aexp * aexp          (* a0 % a1 *) 

  | Proto of pro_ele

  | Sizeof1 of loc * exp_inside * loc
  | Sizeof2 of loc * loc

type bexp =
  | True
  | False
  | EQ of aexp * aexp           (* a0 == a1 *) 
  | LE of aexp * aexp           (* a0 <= a2 *) 
  | BE of aexp * aexp
  | L  of aexp * aexp           (* a0 < a1 *) 
  | B of aexp * aexp 
  | Not of bexp                 (* !b *)
  | And of bexp * bexp          (* b0 /\ b1 *) (* b0 && b1 *) 
  | Or of bexp * bexp           (* b0 \/ b1 *) (* b0 || b1 *) 

type com =
  | Setint of loc * aexp           (* x := a *) 
  | Setbool of loc * bexp
  | Seq of com * com            (* c0 ; c1 *)
  | If of bexp * com		(* if b then c end *)
  | Ifelse of bexp * com * com  (* if b then c0 end else c1 end *)
  | While of bexp * com         (* while b do c *)
  | Print of aexp               (* print a *) 
  
  | Declareint of loc		(* Integer i *)
  | Declarebool of loc
  | Declareproto of loc * loc * loc
  | Readfrom of loc * loc
  | Writeto of loc * loc
 
  | SetProto1 of loc * exp_inside * loc * aexp
  | SetProto2 of loc * exp_inside * loc * int * aexp
  | SetProto3 of loc * loc * aexp
  | SetProto4 of loc * loc * int * aexp

  | AddEle1 of loc * loc * aexp  
  | AddEle2 of loc * exp_inside * loc * aexp
  | AddEle3 of loc * loc
  | AddEle4 of loc * exp_inside * loc

  | Copyfrom of pro_ele * pro_ele
 
(* Pretty-printing utility functions -- these aren't necessary but might be
 * handy for debugging. They convert instances of Aexp, Bexp and Com into
 * strings (that you can print out later with print_string, say). *) 
module P = Printf 

let rec aexp_to_str a = match a with
  | Var l -> l
  | Const n -> string_of_int n
  | Add (a, b) -> P.sprintf "(%s + %s)" (aexp_to_str a) (aexp_to_str b)
  | Sub (a, b) -> P.sprintf "(%s - %s)" (aexp_to_str a) (aexp_to_str b)
  | Mul (a, b) -> P.sprintf "(%s * %s)" (aexp_to_str a) (aexp_to_str b)
  | Div (a, b) -> P.sprintf "(%s / %s)" (aexp_to_str a) (aexp_to_str b)
  | Mod (a, b) -> P.sprintf "(%s % %s)" (aexp_to_str a) (aexp_to_str b)
  
  | Proto p -> P.sprintf "%s" (pro_ele_to_str p)
  | Sizeof1 (l1, e, l2) -> 
      P.sprintf "%s.%s->%s_size()" l1 (exp_inside_to_str e) l2
  | Sizeof2 (l1, l2) ->
      P.sprintf "%s.%s_size()" l1 l2

and pro_ele_to_str p = match p with
  | Var (l) -> l
  | AccessProto1 (l1, e, l2) ->
      P.sprintf "%s.%s->%s()" l1 (exp_inside_to_str e) l2
  | AccessProto2 (l1, e, l2, a) ->
      P.sprintf "%s.%s->%s(%s)" l1 (exp_inside_to_str e) l2 (string_of_int a)
  | AccessProto3 (l1, l2) ->
      P.sprintf "%s.%s()" l1 l2
  | AccessProto4 (l1, l2, a) ->
      P.sprintf "%s.%s(%s)" l1 l2 (string_of_int a)

and bexp_to_str b = match b with
  | True -> "true"
  | False -> "false" 

  | EQ (a, b) -> P.sprintf "(%s = %s)" (aexp_to_str a) (aexp_to_str b) 
  | LE (a, b) -> P.sprintf "(%s <= %s)" (aexp_to_str a) (aexp_to_str b)
  | BE (a, b) -> P.sprintf "(%s >= %s)" (aexp_to_str a) (aexp_to_str b)
  | L (a, b) -> P.sprintf "(%s < %s)" (aexp_to_str a) (aexp_to_str b)
  | B (a, b) -> P.sprintf "(%s > %s)" (aexp_to_str a) (aexp_to_str b)
  | Not b -> P.sprintf "!%s" (bexp_to_str b) 
  | And (a, b) -> P.sprintf "(%s && %s)" (bexp_to_str a) (bexp_to_str b)
  | Or (a, b) -> P.sprintf "(%s || %s)" (bexp_to_str a) (bexp_to_str b)

and com_to_str c = match c with
  | Setint (l, b) -> P.sprintf "%s = %s" l (aexp_to_str b)
  | Setbool (l, b) -> P.sprintf "%s = %s" l (bexp_to_str b) 
  | Seq (a, b) -> P.sprintf "%s ;\n%s" (com_to_str a) (com_to_str b)
  | If (b, c) -> P.sprintf "if (%s) { %s; }" (bexp_to_str b) (com_to_str c)
  | Ifelse (b, c0, c1) ->
      P.sprintf "if (%s) { %s; } \nelse { %s; }"
	(bexp_to_str b) (com_to_str c0) (com_to_str c1) 
  | While (b, c) ->
      P.sprintf "{ while %s do %s }" (bexp_to_str b) (com_to_str c) 
  | Print a -> P.sprintf "print %s" (aexp_to_str a)
  | Declareint l -> P.sprintf "int %s" l
  | Declarebool l -> P.sprintf "bool %s" l
  | Declareproto (l1, l2, l3) -> P.sprintf "%s %s" l3 l1
  | Readfrom (l1, l2) -> 
      P.sprintf "fstream input(%s,ios::in | ios:binary);\n%s.ParseFromIstream(&input)" l2 l1
  | Writeto (l1, l2) -> 
      P.sprintf "fstream output(%s,ios::out | ios:binary);\n%s.SerializeToOstream(&output)" l2 l1
 

 | SetProto1 (l1, e, l2, a) ->
      P.sprintf "%s.%s->set_%s(%s)" l1 (exp_inside_to_str e) l2 (aexp_to_str a)
  | SetProto2 (l1, e, l2, a, b) ->
      P.sprintf "%s.%s->set_%s(%s,%s)" l1 (exp_inside_to_str e) l2 (string_of_int a) (aexp_to_str b)
  | SetProto3 (l1, l2, a) ->
      P.sprintf "%s.set_%s(%s)" l1 l2 (aexp_to_str a)
  | SetProto4 (l1, l2, a, b) ->
      P.sprintf "%s.set_%s(%s, %s)" l1 l2 (string_of_int a) (aexp_to_str b)

  | AddEle1 (l1, l2, a) ->
      P.sprintf "%s.add_%s(%s)" l1 l2 (aexp_to_str a)
  | AddEle2 (l1, e, l2, a) ->
      P.sprintf "%s.%s->add_%s(%s)" l1 (exp_inside_to_str e) l2 (aexp_to_str a)
  | AddEle3 (l1, l2) ->
      P.sprintf "%s.add_%s()" l1 l2
  | AddEle4 (l1, e, l2) ->
      P.sprintf "%s.%s->add_%s()" l1 (exp_inside_to_str e) l2
  | Copyfrom (p1, p2) ->
      P.sprintf "%s = %s" (pro_ele_to_str p1) (pro_ele_to_str p2)


and exp_inside_to_str e = match e with
  | ExpEle1 (l) ->
      P.sprintf "mutable_%s()" l
  | ExpEle2 (l, a) ->
      P.sprintf "mutable_%s(%s)" l (string_of_int a)
  | ExpEle3 (e1, e2) ->
      P.sprintf "%s->%s" (exp_inside_to_str e1) (exp_inside_to_str e2)

let rec find_include c = match c with
  | Setint (a, b) -> "" 
  | Setbool (a, b) -> ""
  | Seq (a, b) -> P.sprintf "%s\n%s" (find_include a) (find_include b)
  | If (b, c) -> P.sprintf "%s" (find_include c)
  | Ifelse (b, c0, c1) -> P.sprintf "%s\n%s" (find_include c0) (find_include c1)
  | While (b, c) -> P.sprintf "%s" (find_include c)
  | Print a -> ""
  | Declareint l -> ""
  | Declarebool l -> ""
  | Declareproto (l1, l2, l3) -> P.sprintf "#include \"%s.pb.h\"" l2
  | Readfrom (l1, l2) -> ""
  | Writeto (l1, l2) -> ""
  | SetProto1 (l1, e,l2, a) -> ""
  | SetProto2 (l1, e, l2, a ,b) -> ""
  | SetProto3 (l1, l2, a) -> ""
  | SetProto4 (l1, l2, a, b) -> ""
  | AddEle1 (l1, l2, a) -> ""
  | AddEle2 (l1, e, l2, a) -> ""
  | AddEle3 (l1, l2) -> ""
  | AddEle4 (l1, e,l2) -> ""
  | Copyfrom (p1, p2) -> ""
