(*
 * Follows Glynn Winskel's _The Formal Semantics of Programming Languages_
 *
 * This is an abstract syntax for IMP. 
 *
 * Do not edit this file -- instead, edit hw1.ml.
 *)
open Imp

(*
type com = Imp.com
type exp_inside = Imp.exp_inside
type pro_ele = Imp.exp_insde
type aexp = Imp.aexp
type bexp = Imp.bexp
type strexp = Imp.strexp

type loc = string

type exp_inside =
  | ExpEle1 of loc
  | ExpEle2 of loc * int
  | ExpEle3 of exp_inside * exp_inside

type pro_ele =
  | Var of loc
  | AccessProto1 of loc * exp_inside * loc
  | AccessProto2 of loc * exp_inside * loc * int
  | AccessProto3 of loc * loc
  | AccessProto4 of loc * loc * int 

type aexp =  (* Winskel page 12 *) 
  | Const of int                (* n *)
  | Var of loc
  | Add of aexp * aexp          (* a0 + a1 *) 
  | Sub of aexp * aexp          (* a0 - a1 *) 
  | Mul of aexp * aexp          (* a0 * a1 *) 
  | Div of aexp * aexp          (* a0 / a1 *) 
  | Mod of aexp * aexp          (* a0 % a1 *) 

  | Proto of pro_ele

  | Sizeof1 of loc * exp_inside * loc
  | Sizeof2 of loc * loc

type bexp =
  | True
  | False
  | EQ of aexp * aexp           (* a0 == a1 *) 
  | LE of aexp * aexp           (* a0 <= a2 *) 
  | BE of aexp * aexp
  | L  of aexp * aexp           (* a0 < a1 *) 
  | B of aexp * aexp 
  | Not of bexp                 (* !b *)
  | And of bexp * bexp          (* b0 /\ b1 *) (* b0 && b1 *) 
  | Or of bexp * bexp           (* b0 \/ b1 *) (* b0 || b1 *) 

type strexp =
  | Str of string
  | PPrint of loc 

type com =
  | Setint of loc * aexp           (* x := a *) 
  | Setbool of loc * bexp
  | Setstr of loc * strexp
  | Seq of com * com            (* c0 ; c1 *)
  | If of bexp * com		(* if b then c end *)
  | Ifelse of bexp * com * com  (* if b then c0 end else c1 end *)
  | While of bexp * com         (* while b do c *)
  | Print of loc
  
  | Declareint of loc		(* Integer i *)
  | Declarebool of loc
  | Declarestr of loc
  | Declareproto of loc * loc * loc
  | Readfrom of loc * loc
  | Writeto of loc * loc
 
  | SetProto1 of loc * exp_inside * loc * aexp
  | SetProto2 of loc * exp_inside * loc * aexp * aexp
  | SetProto3 of loc * loc * aexp
  | SetProto4 of loc * loc * aexp * aexp

  | AddEle1 of loc * loc * aexp  
  | AddEle2 of loc * exp_inside * loc * aexp
  | AddEle3 of loc * loc
  | AddEle4 of loc * exp_inside * loc

  | Copyfrom of pro_ele * pro_ele
 *)
(* Pretty-printing utility functions -- these aren't necessary but might be
 * handy for debugging. They convert instances of Aexp, Bexp and Com into
 * strings (that you can print out later with print_string, say). *) 
module P = Printf 

module StringMap = Map.Make(String)

type env = string StringMap.t 
let empty_env: env = StringMap.empty

let lookup (en: env) (l :loc) : string = 
  try
    StringMap.find l en
  with Not_found -> ""	

let rec check_c (c: com) (en: env): env = match c with
  | Setint (l, a) -> let t = lookup en l in
     if t = "" then failwith ("undefined variable: " ^ l) else 
     if not (t = "Integer") then failwith ("type not match!");
     StringMap.add l "Integer" en 
  | Setbool (l, b) -> en
  | Setstr (l, s) -> en
